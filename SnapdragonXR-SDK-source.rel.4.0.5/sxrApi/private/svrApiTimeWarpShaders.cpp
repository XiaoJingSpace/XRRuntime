//=============================================================================
// FILE: svrApiTimeWarpShaders.cpp
//                  Copyright (c) 2016 QUALCOMM Technologies Inc.
//                              All Rights Reserved.
//
//==============================================================================
#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <sched.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <android/native_window.h>

#include "glm/glm.hpp"
#include "glm/gtc/quaternion.hpp"
#include "glm/gtc/type_ptr.hpp"
#include "glm/gtc/matrix_transform.hpp"
#include "glm/gtx/euler_angles.hpp"
#include "glm/gtx/transform.hpp"

#include "svrCpuTimer.h"
#include "svrGpuTimer.h"
#include "svrGeometry.h"
#include "svrProfile.h"
#include "svrShader.h"
#include "svrUtil.h"
#include "svrConfig.h"

#include "private/svrApiCore.h"
#include "private/svrApiHelper.h"
#include "private/svrApiTimeWarp.h"

using namespace Svr;

// **********************************************
// Debug Blit Shader
// **********************************************
char svrBlitQuadVs[] =
    "#version 300 es\n"
    "in vec4 position;\n"
    "in vec2 texcoord0;\n"
    "layout(location = 1) uniform vec4 posScaleOffset;\n"
    "out vec2 vTexcoord0;\n"
    "void main()\n"
    "{\n"
    "	vTexcoord0 = texcoord0;\n"
    "	// TODO: The W component needs to be passed in.  Currently this breaks rendering if w component used\n"
    "	gl_Position = vec4(position.xy * posScaleOffset.xy + posScaleOffset.zw, position.z, position.w);\n"
    "}\n";  // End of shader string

char svrBlitQuadWarpVs[] =
    "#version 300 es\n"
    "in vec4 position;\n"
    "in vec2 texcoord0;\n"
    "layout(location = 1) uniform vec4 posScaleOffset;\n"
    "layout(location = 2) uniform mat3 transMtx;\n"
    "out vec2 vTexcoord0;\n"
    "void main()\n"
    "{\n"
    "    // Since using a warp matrix, need texture coordinates in [-1, 1]\n"
    "    vec2 newCoord = 2.0 * texcoord0 + vec2(-1.0, -1.0);\n"
    "    vec3 tmpTexCoords = transMtx * vec3(newCoord.xy, 1.0);\n"
    "    vTexcoord0 = 0.5 * tmpTexCoords.xy + vec2(0.5, 0.5);\n"
    "    gl_Position = vec4(position.xy * posScaleOffset.xy + posScaleOffset.zw, position.z, position.w);\n"
    "}\n";  // End of shader string

char svrBlitQuadFs[] =
    "#version 300 es\n"
    "precision highp float;\n"
    "uniform sampler2D srcTex;\n"
    "in vec2 vTexcoord0;\n"
    "out vec4 outColor;\n"
    "void main()\n"
    "{\n"
    "	vec4 srcColor = texture(srcTex, vTexcoord0);\n"
    "	outColor = vec4(srcColor.xyz,srcColor.a);\n"
    "}\n";  // End of shader string

char svrBlitQuadYuvFs[] =
    "#version 300 es\n"
    "\n"
    "#extension GL_EXT_YUV_target : require\n"
    "\n"
    "precision highp float;\n"
    "uniform sampler2D srcTex;\n"
    "in vec2 vTexcoord0;\n"
    "layout (yuv) out vec3 outColor;\n"
    "void main()\n"
    "{\n"
    "	if(vTexcoord0.x < 0.0 || vTexcoord0.x > 1.0 || vTexcoord0.y < 0.0 || vTexcoord0.y > 1.0)\n"
    "	    discard;\n"
    "   // Need to switch row and columns based on how data comes in\n"
    "	// vec4 srcColor = texture(srcTex, vec2(1.0 - vTexcoord0.y, vTexcoord0.x));\n"
    "	vec4 srcColor = texture(srcTex, vTexcoord0);\n"
    "	outColor = vec3(srcColor.xyz);\n"
    "}\n";  // End of shader string

char svrBlitQuadYuvFs_Array[] =
    "#version 300 es\n"
    "\n"
    "#extension GL_EXT_YUV_target : require\n"
    "\n"
    "precision highp float;\n"
    "\n"
    "uniform sampler2DArray srcTex;\n"
    "\n"
    "layout(location = 9) uniform vec4 arrayLayer;\n"
    "\n"
    "in vec2 vTexcoord0;\n"
    "\n"
    "layout (yuv) out vec3 outColor;\n"
    "void main()\n"
    "{\n"
    "	if(vTexcoord0.x < 0.0 || vTexcoord0.x > 1.0 || vTexcoord0.y < 0.0 || vTexcoord0.y > 1.0)\n"
    "	    discard;\n"
    "\n"
    "   vec4 srcColor = texture(srcTex, vec3(vTexcoord0.xy, arrayLayer.x));\n"
    "	outColor = vec3(srcColor.xyz);\n"
    "}\n";  // End of shader string

char svrBlitQuadFs_Image[] =
    "#version 300 es\n"
    "\n"
    "#extension GL_OES_EGL_image_external_essl3 : require\n"
    "\n"
    "precision highp float;\n"
    "uniform samplerExternalOES srcTex;\n"
    "in vec2 vTexcoord0;\n"
    "out vec4 outColor;\n"
    "void main()\n"
    "{\n"
    "	vec4 srcColor = texture(srcTex, vTexcoord0);\n"
    "	outColor = vec4(srcColor.xyz,srcColor.a);\n"
    "}\n";  // End of shader string

char svrBlitQuadYuvFs_Image[] =
    "#version 300 es\n"
    "\n"
    "#extension GL_OES_EGL_image_external_essl3 : require\n"
    "#extension GL_EXT_YUV_target : require\n"
    "\n"
    "precision highp float;\n"
    "uniform samplerExternalOES srcTex;\n"
    "in vec2 vTexcoord0;\n"
    "layout (yuv) out vec3 outColor;\n"
    "void main()\n"
    "{\n"
    "   // Need to switch row and columns based on how data comes in\n"
    "	// vec4 srcColor = texture(srcTex, vec2(1.0 - vTexcoord0.y, vTexcoord0.x));\n"
    "	vec4 srcColor = texture(srcTex, vTexcoord0);\n"
    "	outColor = vec3(srcColor.xyz);\n"
    "}\n";  // End of shader string

// **********************************************
// Stencil Shader
// **********************************************
char svrStencilVs[] =
    "#version 300 es\n"
    "in vec3 position;\n"
    "layout(location = 1) uniform vec4 posScaleOffset;\n"
    "layout(location = 2) uniform vec4 depthValue;\n"
    "void main()\n"
    "{\n"
    "	gl_Position = vec4(position.xy * posScaleOffset.xy + posScaleOffset.zw, depthValue.z, 1.0);\n"
    "}\n";  // End of shader string

char svrStencilArrayVs[] =
    "#version 300 es\n"
    "\n"
    "#extension GL_OVR_multiview : enable\n"
    "#extension GL_OVR_multiview2 : enable\n"
    "#extension GL_OVR_multiview_multisampled_render_to_texture : enable\n"
    "\n"
    "layout(num_views = 2) in;\n"
    "\n"
    "in vec3 position;\n"
    "layout(location = 1) uniform vec4 posScaleOffset;\n"
    "layout(location = 2) uniform vec4 depthValue;\n"
    "void main()\n"
    "{\n"
    "	gl_Position = vec4(position.xy * posScaleOffset.xy + posScaleOffset.zw, depthValue.z, 1.0);\n"
    "}\n";  // End of shader string

char svrStencilFs[] =
    "#version 300 es\n"
    "precision highp float;\n"
    "layout(location = 3) uniform vec4 stencilColor;\n"
    "out vec4 outColor;\n"
    "void main()\n"
    "{\n"
    "	outColor = stencilColor;\n"
    "}\n";  // End of shader string

// **********************************************
// Occluder Shader
// **********************************************
char svrOccluderVs[] =
"#version 300 es\n"
"in vec3 position;\n"
"layout(location = 1) uniform mat4 projMtx;\n"
"layout(location = 2) uniform mat4 viewMtx;\n"
"layout(location = 3) uniform mat4 mdlMtx;\n"
"void main()\n"
"{\n"
"	gl_Position = projMtx * (viewMtx * (mdlMtx * vec4(position.xyz, 1.0)));\n"
"}\n";  // End of shader string

char svrOccluderArrayVs[] =
"#version 300 es\n"
"\n"
"#extension GL_OVR_multiview : enable\n"
"#extension GL_OVR_multiview2 : enable\n"
"#extension GL_OVR_multiview_multisampled_render_to_texture : enable\n"
"\n"
"layout(num_views = 2) in;\n"
"\n"
"in vec3 position;\n"
"layout(location = 1) uniform mat4 projMtx;\n"
"layout(location = 2) uniform mat4 viewMtx;\n"
"layout(location = 3) uniform mat4 mdlMtx;\n"
"void main()\n"
"{\n"
"	gl_Position = projMtx * (viewMtx * (mdlMtx * vec4(position.xyz, 1.0)));\n"
"}\n";  // End of shader string

char svrOccluderFs[] =
"#version 300 es\n"
"precision highp float;\n"
"layout(location = 4) uniform vec4 occludeColor;\n"
"out vec4 outColor;\n"
"void main()\n"
"{\n"
"   float depth = 0.2/gl_FragCoord.w;"
"   outColor = occludeColor * vec4(vec3(1.0 - depth), 1.0);\n"
"}\n";  // End of shader string

// **********************************************
// Boundary Mesh Shader
// **********************************************
char svrBoundaryMeshVs[] =
"#version 300 es\n"
"\n"
"in vec3 position;      // Position\n"
"in vec2 texcoord0;     // Tex Coord\n"
"\n"
"layout(location = 1) uniform mat4 projMtx;\n"
"layout(location = 2) uniform mat4 viewMtx;\n"
"layout(location = 3) uniform mat4 mdlMtx;\n"
"\n"
"out vec2 vTexcoord;\n"
"\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"void main()\n"
"//-----------------------------------------------------------------------------\n"
"{\n"
"\n"
"\n"
"	vTexcoord.xy = texcoord0.xy;\n"
"	gl_Position = projMtx * (viewMtx * (mdlMtx * vec4(position.xyz, 1.0)));\n"
"}\n";  // End of shader string

char svrBoundaryMeshArrayVs[] =
"#version 300 es\n"
"\n"
"#extension GL_OVR_multiview : enable\n"
"#extension GL_OVR_multiview2 : enable\n"
"#extension GL_OVR_multiview_multisampled_render_to_texture : enable\n"
"\n"
"layout(num_views = 2) in;\n"
"\n"
"in vec3 position;      // Position\n"
"in vec2 texcoord0;     // Tex Coord\n"
"\n"
"layout(location = 1) uniform mat4 projMtx;\n"
"layout(location = 2) uniform mat4 viewMtx;\n"
"layout(location = 3) uniform mat4 mdlMtx;\n"
"\n"
"out vec2 vTexcoord;\n"
"\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"void main()\n"
"//-----------------------------------------------------------------------------\n"
"{\n"
"\n"
"\n"
"	vTexcoord.xy = texcoord0.xy;\n"
"	gl_Position = projMtx * (viewMtx * (mdlMtx * vec4(position.xyz, 1.0)));\n"
"}\n";  // End of shader string


char svrBoundaryMeshFs[] =
"#version 300 es\n"
"\n"
"layout(location = 4) uniform vec4 BoundaryColor;\n"
"\n"
"// X: Width\n"
"// Y: Not Used\n"
"// Z: Not Used\n"
"// W: Not Used\n"
"layout(location = 5) uniform vec4 BoundaryParams;\n"
"// uniform sampler2D srcTex;\n"
"\n"
"in vec2 vTexcoord; \n"
"\n"
"out vec4 outColor;\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"void main()\n"
"//-----------------------------------------------------------------------------\n"
"{\n"
"    // vec4 TexColor = texture(srcTex, vTexcoord.xy);\n"
"\n"
"    // vec4 BaseColor = vec4(TexColor.r, TexColor.g, TexColor.b, TexColor.a);\n"
"    vec4 BaseColor = BoundaryColor;\n"
"\n"
"    vec2 fractPart = fract(vTexcoord.xy);\n"
"    vec2 gridLerp = step(BoundaryParams.x, fractPart);\n"
"\n"
"    vec4 clearColor = vec4(0.0, 0.0, 0.0, 0.0);\n"
"\n"
"    // Edge can really be anything :)\n"
"    float lerpValue = step(0.5, gridLerp.x + gridLerp.y);\n"
"\n"
"    outColor = mix(clearColor, BoundaryColor, lerpValue);\n"
"\n"
"}\n";   // End of shader string

// **********************************************
// Warp Shader - Vertex
// **********************************************
char warpShaderVs[] =
"\n"
"// Version, Precision, and conditional compiles will be added above\n"
"\n"
"in vec4 position;      // Position\n"
"in vec4 normal;        // Red\n"
"in vec4 color;         // Green\n"
"in vec4 texcoord0;     // Blue\n"
"\n"
"layout(location = 1) uniform vec4 posScaleOffset;\n"
"\n"
"#ifdef PROJECTION_SUPPORT\n"
"    #ifdef COLOR_PLANE_SUPPORT\n"
"        layout(location = 2) uniform mat4 textureMtx[3];\n"
"    #else\n"
"        layout(location = 2) uniform mat4 textureMtx;\n"
"    #endif // COLOR_PLANE_SUPPORT\n"
"#endif     // Projection Support\n"
"\n"
"#ifdef UV_SCALE_SUPPORT\n"
"    layout(location = 4) uniform vec4 uvScaleOffset;\n"
"#endif     // UV Scale\n"
"\n"
"#ifdef SUPPORT_SPHERE_MESH\n"
"    layout(location = 6) uniform mat4 modelMtx;\n"
"#endif     // Sphere Mesh Support\n"
"\n"
"    layout(location = 10) uniform mat2 skewSquashMatrix;\n"
"\n"
"#ifdef SUPPORT_SPHERE_MESH\n"
"   out vec4 v_WorldPosG;\n"
"#ifdef CHROMATIC_SUPPORT\n"
"   out vec4 v_WorldPosR;\n"
"   out vec4 v_WorldPosB;\n"
"#endif     // Chromatic Support\n"
"\n"
"#else     // Sphere Mesh Support\n"
"\n"
"out vec2 vTexcoordG;\n"
"\n"
"#ifdef SPACEWARP_SUPPORT\n"
"uniform sampler2D spacewarpTex;\n"
"layout(location = 12) uniform vec4 spacewarpScaleOffset;\n"
"#endif // SPACEWARP_SUPPORT\n"
"\n"
"#ifdef CHROMATIC_SUPPORT\n"
"    out vec2 vTexcoordR;\n"
"    out vec2 vTexcoordB;\n"
"#endif     // Chromatic Support\n"
"\n"
"#endif     // Sphere Mesh Support\n"
"\n"
"#ifdef VIGNETTE_SUPPORT\n"
"    out vec3 vVignetteFactor;\n"
"#endif     // Vignette Support\n"
"\n"
"//-----------------------------------------------------------------------------\n"
"void main()\n"
"//-----------------------------------------------------------------------------\n"
"{\n"
"   vec4 tmpTexCoords;\n"
"#ifdef PROJECTION_SUPPORT\n"
"	float projIZ;\n"
"#endif     // Projection Support\n"
"\n"
"#ifdef VIGNETTE_SUPPORT\n"
"#ifdef CHROMATIC_SUPPORT\n"
"   vVignetteFactor = vec3(color.w, normal.w, texcoord0.w);\n"
"#else\n"
"   vVignetteFactor = vec3(color.w, 1.0, 1.0);\n"
"#endif     // Chromatic Support\n"
"#endif     // Vignette Support\n"
"\n"
"#ifdef SUPPORT_SPHERE_MESH\n"
"   // Need the world position for the fragment shader\n"
"	v_WorldPosG = (modelMtx * vec4(color.xyz, 1.0));\n"
"#ifdef CHROMATIC_SUPPORT\n"
"	v_WorldPosR = (modelMtx * vec4(normal.xyz, 1.0));\n"
"	v_WorldPosB = (modelMtx * vec4(texcoord0.xyz, 1.0));\n"
"#endif     // Chromatic Support\n"
"#else      // Sphere Mesh Support\n"
"\n"
"   // ******************************\n"
"   // Texture coordinates are projected values\n"
"   // ******************************\n"
"   // Green\n"
"#ifdef PROJECTION_SUPPORT\n"
"#ifdef COLOR_PLANE_SUPPORT\n"
"   tmpTexCoords = textureMtx[1] * vec4(color.xy, -1.0, 1.0);\n"
"#else\n"
"   tmpTexCoords = textureMtx * vec4(color.xy, -1.0, 1.0);\n"
"#endif // COLOR_PLANE_SUPPORT\n"
"	projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"	vTexcoordG = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
"   vTexcoordG.y = vTexcoordG.y - 1.0;\n"
"   vTexcoordG = vTexcoordG * skewSquashMatrix;\n"
"   vTexcoordG.y = vTexcoordG.y + 1.0;\n"
"#if defined(SUPPORT_CAMERA_MONO_INT16) || defined(SUPPORT_CAMERA_COLOR) || defined(SUPPORT_CAMERA_COLOR_SWAP) || defined(SUPPORT_CAMERA_MONO_8_10BIT)\n"
"	vTexcoordG = vec2( color.z-(color.x-vTexcoordG.x), color.w-(color.y-vTexcoordG.y));\n"
"#endif\n"
"	vTexcoordG = 0.5 * vTexcoordG + vec2(0.5, 0.5);\n"
"#else\n"
"   vTexcoordG.y = vTexcoordG.y - 1.0;\n"
"   vTexcoordG = vTexcoordG * skewSquashMatrix;\n"
"   vTexcoordG.y = vTexcoordG.y + 1.0;\n"
"	vTexcoordG = 0.5 * color.xy + vec2(0.5, 0.5);\n"
"#endif     // Projection Support\n"
"\n"
"#ifdef UV_SCALE_SUPPORT\n"
"	vTexcoordG = uvScaleOffset.xy * vTexcoordG.xy + uvScaleOffset.zw;\n"
"\n"
"#endif // UV_SCALE_SUPPORT\n"
"\n"
"#ifdef CHROMATIC_SUPPORT\n"
"   // Red\n"
"#ifdef PROJECTION_SUPPORT\n"
"#ifdef COLOR_PLANE_SUPPORT\n"
"   tmpTexCoords = textureMtx[0] * vec4(normal.xy, -1.0, 1.0);\n"
"#else\n"
"   tmpTexCoords = textureMtx * vec4(normal.xy, -1.0, 1.0);\n"
"#endif // COLOR_PLANE_SUPPORT\n"
"	projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"	vTexcoordR = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
"   vTexcoordR.y = vTexcoordR.y - 1.0;\n"
"   vTexcoordR = vTexcoordR * skewSquashMatrix;\n"
"   vTexcoordR.y = vTexcoordR.y + 1.0;\n"
"#if defined(SUPPORT_CAMERA_MONO_INT16) || defined(SUPPORT_CAMERA_COLOR) || defined(SUPPORT_CAMERA_COLOR_SWAP) || defined(SUPPORT_CAMERA_MONO_8_10BIT)\n"
"	vTexcoordR = vec2( normal.z-(normal.x-vTexcoordR.x), normal.w-(normal.y-vTexcoordR.y));\n"
"#endif\n"
"	vTexcoordR = 0.5 * vTexcoordR + vec2(0.5, 0.5);\n"
"#else\n"
"   vTexcoordR.y = vTexcoordR.y - 1.0;\n"
"   vTexcoordR = vTexcoordR * skewSquashMatrix;\n"
"   vTexcoordR.y = vTexcoordR.y + 1.0;\n"
"	vTexcoordR = 0.5 * normal.xy + vec2(0.5, 0.5);\n"
"#endif     // Projection Support\n"
"#ifdef UV_SCALE_SUPPORT\n"
"	vTexcoordR = uvScaleOffset.xy * vTexcoordR.xy + uvScaleOffset.zw;\n"
"#endif\n"
"\n"
"   // Blue\n"
"#ifdef PROJECTION_SUPPORT\n"
"#ifdef COLOR_PLANE_SUPPORT\n"
"   tmpTexCoords = textureMtx[2] * vec4(texcoord0.xy, -1.0, 1.0);\n"
"#else\n"
"   tmpTexCoords = textureMtx * vec4(texcoord0.xy, -1.0, 1.0);\n"
"#endif // COLOR_PLANE_SUPPORT\n"
"	projIZ = 1.0 / max( tmpTexCoords.z, 0.00001 );\n"
"	vTexcoordB = vec2( tmpTexCoords.x * projIZ, tmpTexCoords.y * projIZ );\n"
"   vTexcoordB.y = vTexcoordB.y - 1.0;\n"
"   vTexcoordB = vTexcoordB * skewSquashMatrix;\n"
"   vTexcoordB.y = vTexcoordB.y + 1.0;\n"
"#if defined(SUPPORT_CAMERA_MONO_INT16) || defined(SUPPORT_CAMERA_COLOR) || defined(SUPPORT_CAMERA_COLOR_SWAP) || defined(SUPPORT_CAMERA_MONO_8_10BIT)\n"
"	vTexcoordB = vec2( texcoord0.z-(texcoord0.x-vTexcoordB.x), texcoord0.w-(texcoord0.y-vTexcoordB.y));\n"
"#endif\n"
"	vTexcoordB = 0.5 * vTexcoordB + vec2(0.5, 0.5);\n"
"#else\n"
"   vTexcoordB.y = vTexcoordB.y - 1.0;\n"
"   vTexcoordB = vTexcoordB * skewSquashMatrix;\n"
"   vTexcoordB.y = vTexcoordB.y + 1.0;\n"
"	vTexcoordB = 0.5 * texcoord0.xy + vec2(0.5, 0.5);\n"
"#endif     // Projection Support\n"
"#ifdef UV_SCALE_SUPPORT\n"
"	vTexcoordB = uvScaleOffset.xy * vTexcoordB.xy + uvScaleOffset.zw;\n"
"#endif\n"
"#endif     // Chromatic\n"
"\n"
"#endif     // Sphere Mesh Support\n"
"\n"
"    vec2 pos = position.xy;\n"
"#ifdef SPACEWARP_SUPPORT\n"
     // Move the vertex based on the motion vector at the given coordinates, scaled by the desired extrapolation magnitude
"    pos -= (texture(spacewarpTex, vTexcoordG.xy).xy) / spacewarpScaleOffset.xy;\n"
"#endif // SPACEWARP_SUPPORT\n"
"    gl_Position = vec4(pos * posScaleOffset.xy + posScaleOffset.zw, position.z, position.w);\n"
"\n"
"}\n";  // End of shader string

// **********************************************
// Warp Shader - Fragment MAIN
// **********************************************
char warpShaderFs[] =
"\n"
"// Version, Precision, and conditional compiles will be added above\n"
"\n"
"#ifdef UV_CLAMP_SUPPORT\n"
"layout(location = 3) uniform vec4 eyeBorder;\n"
"#endif\n"
"\n"
"#ifdef VIGNETTE_SUPPORT\n"
"layout(location = 7) uniform vec4 vignetteParams;\n"
"#endif     // Vignette Support\n"
"\n"
"#ifdef SUPPORT_SPHERE_MESH\n"
"    layout(location = 8) uniform mat4 transformMtx;\n"
"#endif     // Sphere Mesh Support\n"
"\n"
"#ifdef SPACEWARP_GPU_SUPPORT\n"
"// X: Spacewarp Texture Width\n"
"// Y: Spacewarp Texture Height\n"
"// Z: Spacewarp Texture One Pixel Width\n"
"// W: Spacewarp Texture One Pixel Height\n"
"layout(location = 11) uniform vec4 spacewarpParams;\n"
"#endif // Spacewarp GPU Support \n"
"\n"
"#if defined(ARRAY_SUPPORT)\n"
"   uniform sampler2DArray srcTex;\n"
"#elif defined(IMAGE_SUPPORT)\n"
"   uniform samplerExternalOES srcTex;\n"
"#elif defined(SUPPORT_CUBEMAP)\n"
"   uniform samplerCube srcTex;\n"
"#elif defined(SUPPORT_SUBSAMPLED)\n"
"   layout(subsampled) uniform mediump sampler2D srcTex;\n"
"#elif defined(SUPPORT_CAMERA_MONO_INT16)\n"
"   uniform highp usampler2D srcTex;\n"
"#elif defined(SUPPORT_CAMERA_COLOR)\n"
"   uniform highp samplerExternalOES srcTex;\n"
"#elif defined(SUPPORT_CAMERA_COLOR_SWAP)\n"
"   uniform highp samplerExternalOES srcTex;\n"
"#elif defined(SUPPORT_CAMERA_MONO_8_10BIT)\n"
"   uniform highp samplerExternalOES srcTex;\n"
"#else\n"
"   uniform highp sampler2D srcTex;\n"
"#endif  // Sampler Type\n"
"\n"
"#ifdef SUPPORT_SPHERE_MESH\n"
"   in vec4 v_WorldPosG;\n"
"#ifdef CHROMATIC_SUPPORT\n"
"   in vec4 v_WorldPosR;\n"
"   in vec4 v_WorldPosB;\n"
"#endif     // Chromatic Support\n"
"\n"
"#else     // Sphere Mesh Support\n"
"\n"
"in vec2 vTexcoordG; \n"
"\n"
"#ifdef CHROMATIC_SUPPORT\n"
"in vec2 vTexcoordR;\n"
"in vec2 vTexcoordB;\n"
"\n"
"#endif\n"
"#endif     // Sphere Mesh Support\n"
"\n"
"#ifdef ARRAY_SUPPORT\n"
"layout(location = 9) uniform vec4 arrayLayer;\n"
"#endif\n"
"\n"
"#ifdef VIGNETTE_SUPPORT\n"
"in vec3 vVignetteFactor;\n"
"#endif     // Vignette Support\n"
"\n"
"out vec4 outColor;\n"
"\n"
"#ifdef SUPPORT_EQUIRECTANGULAR\n"
"//--------------------------------------------------------------------------------------\n"
"vec2 FragGetEquiRectCoord(vec3 WorldVector)\n"
"//--------------------------------------------------------------------------------------\n"
"{\n"
"    // U - Based on XZ (atan is [-pi, pi])\n"
"    float UValue = atan(WorldVector.x, WorldVector.z) / 3.14159265358979323846;\n"
"    UValue = UValue * 0.5 + 0.5;\n"
"\n"
"    // V - Based on Y (asin is [-pi/2, pi/2] => [-1,1] => [0, 1])\n"
"    float VValue = 2.0 * asin(WorldVector.y) / 3.14159265358979323846;\n"
"    VValue = VValue * 0.5 + 0.5;\n"
"\n"
"    return vec2(1.0 - UValue, VValue);\n"
"}\n"
"#endif // Equirectangular\n"
"\n"

/**********************************************************
 * MAIN
 **********************************************************/
"void main()\n"
"{\n"

/**********************************************************
 * BEGIN SPHERE
 **********************************************************/
"#ifdef SUPPORT_SPHERE_MESH\n"
"    // First, figure out texture UV Coordinates\n"
"    vec3 normalizedPosG = normalize(v_WorldPosG.xyz);\n"
"    #ifdef SUPPORT_EQUIRECTANGULAR\n"
"        vec2 eqrCoordG = FragGetEquiRectCoord(normalizedPosG.xyz);\n"
"        vec4 xformCoordG = transformMtx * vec4(eqrCoordG.xy, 0.0, 1.0);\n"
"        #ifdef  ARRAY_SUPPORT\n"
"            vec4 TexColorG = texture(srcTex, vec3(xformCoordG.xy, arrayLayer.x));\n"
"        #else\n"
"            vec4 TexColorG = texture(srcTex, xformCoordG.xy);\n"
"        #endif // Array Support\n"
"    #elif defined(SUPPORT_CUBEMAP)\n"
"        vec4 xformCoordG = transformMtx * vec4(normalizedPosG.xyz, 1.0);\n"
"        vec4 TexColorG = textureLod(srcTex, xformCoordG.xyz, 1.0);\n"
"    #endif // Equirectangular|Cube Support\n"
"    \n"
"   #ifdef CHROMATIC_SUPPORT\n"
"       vec3 normalizedPosR = normalize(v_WorldPosR.xyz);\n"
"       #ifdef SUPPORT_EQUIRECTANGULAR\n"
"           vec2 eqrCoordR = FragGetEquiRectCoord(normalizedPosR.xyz);\n"
"           vec4 xformCoordR = transformMtx * vec4(eqrCoordR.xy, 0.0, 1.0);\n"
"           #ifdef  ARRAY_SUPPORT\n"
"               vec4 TexColorR = texture(srcTex, vec3(xformCoordR.xy, arrayLayer.x));\n"
"           #else\n"
"               vec4 TexColorR = texture(srcTex, xformCoordR.xy);\n"
"           #endif // Array Support\n"
"       #elif defined(SUPPORT_CUBEMAP)\n"
"           vec4 xformCoordR = transformMtx * vec4(normalizedPosR.xyz, 1.0);\n"
"           vec4 TexColorR = textureLod(srcTex, xformCoordR.xyz, 1.0);\n"
"       #endif // Equirectangular|Cube Support\n"
"       \n"
"       vec3 normalizedPosB = normalize(v_WorldPosB.xyz);\n"
"       #ifdef SUPPORT_EQUIRECTANGULAR\n"
"           vec2 eqrCoordB = FragGetEquiRectCoord(normalizedPosB.xyz);\n"
"           vec4 xformCoordB = transformMtx * vec4(eqrCoordB.xy, 0.0, 1.0);\n"
"           #ifdef  ARRAY_SUPPORT\n"
"               vec4 TexColorB = texture(srcTex, vec3(xformCoordB.xy, arrayLayer.x));\n"
"           #else\n"
"               vec4 TexColorB = texture(srcTex, xformCoordB.xy);\n"
"           #endif // Array Support\n"
"       #elif defined(SUPPORT_CUBEMAP)\n"
"           vec4 xformCoordB = transformMtx * vec4(normalizedPosB.xyz, 1.0);\n"
"           vec4 TexColorB = textureLod(srcTex, xformCoordB.xyz, 1.0);\n"
"       #endif // Equirectangular|Cube Support\n"
"   #endif // Chromatic Support\n"
"   \n"
"   #ifdef CHROMATIC_SUPPORT\n"
"       vec4 BaseColor = vec4(TexColorR.r, TexColorG.g, TexColorB.b, TexColorG.a);\n"
"   #else\n"
"       vec4 BaseColor = vec4(TexColorG.r, TexColorG.g, TexColorG.b, TexColorG.a);\n"
"   #endif\n"
"   \n"
"       outColor = BaseColor;\n"
"   \n"
/**********************************************************
 * END SPHERE
 **********************************************************/

/**********************************************************
 * BEGIN CAMERA
 **********************************************************/
/*
 * Monochrome Camera - 16 bit float raw
 */
"#elif defined(SUPPORT_CAMERA_MONO_F16)\n"

"    vec2 localTexcoordR = vTexcoordR.xy; \n"
"    vec2 localTexcoordG = vTexcoordG.xy; \n"
"    vec2 localTexcoordB = vTexcoordB.xy; \n"
"                                          \n"
"    float red = texture(srcTex, 1.0 - localTexcoordR.xy).r * 64.0;\n"
"    float green = texture(srcTex, 1.0 - localTexcoordG.xy).r * 64.0;\n"
"    float blue = texture(srcTex, 1.0 - localTexcoordB.xy).r * 64.0;\n"

"    vec4 BaseColor = vec4(red, green, blue, 1.0);\n"
"    outColor = BaseColor;\n"
"                                          \n"
/*
 * Monochrome Camera - 16 bit integer raw
 */
"#elif defined(SUPPORT_CAMERA_MONO_INT16)\n"

"    vec2 localTexcoordR = vTexcoordR.xy; \n"
"    vec2 localTexcoordG = vTexcoordG.xy; \n"
"    vec2 localTexcoordB = vTexcoordB.xy; \n"
"                                          \n"
"    float red   = float(texture(srcTex, 1.0 - localTexcoordR.xy).r) / 1024.0f;\n"
"    float green = float(texture(srcTex, 1.0 - localTexcoordG.xy).r)  / 1024.0f;\n"
"    float blue  = float(texture(srcTex, 1.0 - localTexcoordB.xy).r) / 1024.0f;\n"
"                                          \n"
"    vec4 BaseColor = vec4(red, green, blue, 1.0);\n"
"    outColor = BaseColor;\n"
"                                          \n"
/*
 * Color Camera
 */
"#elif defined(SUPPORT_CAMERA_COLOR)\n"
"    vec2 localTexcoordR = vTexcoordR.xy; \n"
"    vec2 localTexcoordG = vTexcoordG.xy; \n"
"    vec2 localTexcoordB = vTexcoordB.xy; \n"
"    vec4 BaseColor;\n"
"    const float border_width = 0.0001;\n"
"                                          \n"
"    if(localTexcoordR.x >border_width && localTexcoordR.x<(1.0-border_width) && localTexcoordR.y > border_width && localTexcoordR.y<(1.0-border_width))\n"
"    {\n"
"        vec4 TexColorR = texture(srcTex, vec2(localTexcoordR.x, 1.0- localTexcoordR.y));\n"
"        vec4 TexColorG = texture(srcTex, vec2(localTexcoordG.x, 1.0- localTexcoordG.y));\n"
"        vec4 TexColorB = texture(srcTex, vec2(localTexcoordB.x, 1.0 -localTexcoordB.y));\n"
"        BaseColor = vec4(TexColorR.r, TexColorG.g, TexColorB.b, 1.0);\n"
"    }\n"
"    else {\n"
"       BaseColor  = vec4(0.0, 0.0, 0.0, 1.0);\n"
"    }\n"
"    outColor = BaseColor;\n"
/*
 * Color Camera w/PFD
 */
"#elif defined(SUPPORT_CAMERA_COLOR_SWAP)\n"
"    vec2 localTexcoordR = vTexcoordB.xy; \n"
"    vec2 localTexcoordG = vTexcoordG.xy; \n"
"    vec2 localTexcoordB = vTexcoordR.xy; \n"
"    vec4 BaseColor;\n"
"    const float border_width = 0.0001;\n"
"                                          \n"
"    if(localTexcoordR.x >border_width && localTexcoordR.x<(1.0-border_width) && localTexcoordR.y > border_width && localTexcoordR.y<(1.0-border_width))\n"
"    {\n"
"        vec4 TexColorR = texture(srcTex, vec2(localTexcoordR.x, 1.0- localTexcoordR.y));\n"
"        vec4 TexColorG = texture(srcTex, vec2(localTexcoordG.x, 1.0- localTexcoordG.y));\n"
"        vec4 TexColorB = texture(srcTex, vec2(localTexcoordB.x, 1.0 -localTexcoordB.y));\n"
"        BaseColor = vec4(TexColorB.b, TexColorG.g, TexColorR.r, 1.0);\n"
"    }\n"
"    else {\n"
"       BaseColor  = vec4(0.0, 0.0, 0.0, 1.0);\n"
"    }\n"
"    outColor = BaseColor;\n"
//
/*
 * Monochrome Camera - 8 or 10 bit raw
 */
"#elif defined(SUPPORT_CAMERA_MONO_8_10BIT)\n"

"    vec2 localTexcoordR = vTexcoordR.xy; \n"
"    vec2 localTexcoordG = vTexcoordG.xy; \n"
"    vec2 localTexcoordB = vTexcoordB.xy; \n"
"                                          \n"
"    vec4 TexColorR = texture(srcTex, localTexcoordR.xy);\n"
"    vec4 TexColorG = texture(srcTex, localTexcoordG.xy);\n"
"    vec4 TexColorB = texture(srcTex, localTexcoordB.xy);\n"

"    vec4 BaseColor = vec4(TexColorR.r, TexColorG.r, TexColorB.r, 1.0);\n"
"    outColor = BaseColor;\n"

/**********************************************************
 * END CAMERA
 **********************************************************/

"#else    // other cases \n"

/**********************************************************
 * BEGIN ALL OTHER CASES (e.g. normal image layer)
 **********************************************************/
"    vec2 localTexcoordG = vTexcoordG.xy; \n"
"#ifdef CHROMATIC_SUPPORT\n"
"    vec2 localTexcoordR = vTexcoordR.xy; \n"
"    vec2 localTexcoordB = vTexcoordB.xy; \n"
"#endif\n"
"\n"
"   #ifdef UV_CLAMP_SUPPORT\n"
"    vec4 TexColorG = texture(srcTex, vec2( clamp( localTexcoordG.x, eyeBorder.x, eyeBorder.y), localTexcoordG.y));\n"
"   #else\n"
"#ifdef  ARRAY_SUPPORT\n"
"    vec4 TexColorG = texture(srcTex, vec3(localTexcoordG.xy, arrayLayer.x));\n"
"   #else\n"
"    vec4 TexColorG = texture(srcTex, localTexcoordG.xy);\n"
"   #endif\n"
"   #endif\n"
"   \n"
"   #ifdef CHROMATIC_SUPPORT\n"
"   #ifdef UV_CLAMP_SUPPORT\n"
"    vec4 TexColorR = texture(srcTex, vec2( clamp( localTexcoordR.x, eyeBorder.x, eyeBorder.y), localTexcoordR.y));\n"
"    vec4 TexColorB = texture(srcTex, vec2( clamp( localTexcoordB.x, eyeBorder.x, eyeBorder.y), localTexcoordB.y));\n"
"   #else\n"
"#ifdef  ARRAY_SUPPORT\n"
"    vec4 TexColorR = texture(srcTex, vec3(localTexcoordR.xy, arrayLayer.x));\n"
"    vec4 TexColorB = texture(srcTex, vec3(localTexcoordB.xy, arrayLayer.x));\n"
"   #else\n"
"    vec4 TexColorR = texture(srcTex, localTexcoordR.xy);\n"
"    vec4 TexColorB = texture(srcTex, localTexcoordB.xy);\n"
"   #endif\n"
"   #endif\n"
"   \n"
"   #endif\n"
"   \n"
"       // Combine the colors to get final results\n"
"   #ifdef CHROMATIC_SUPPORT\n"
"       vec4 BaseColor = vec4(TexColorR.r, TexColorG.g, TexColorB.b, TexColorG.a);\n"
"   #else\n"
"       vec4 BaseColor = vec4(TexColorG.r, TexColorG.g, TexColorG.b, TexColorG.a);\n"
"   #endif\n"
"   \n"
"   outColor = BaseColor;\n"
"   \n"
/**********************************************************
 * END MESH CASES
 **********************************************************/
"#endif     // Mesh cases\n"

/**********************************************************
 * POST PROCESSING
 **********************************************************/
"\n"

"#if defined(SUPPORT_CAMERA_MONO_INT16) || defined(SUPPORT_CAMERA_COLOR) || defined(SUPPORT_CAMERA_COLOR_SWAP) || defined(SUPPORT_CAMERA_MONO_8_10BIT)\n"
"//no vignette for camera\n"
"#else\n"
"#ifdef VIGNETTE_SUPPORT\n"
"    // Vignette Data: [Start Radius, End Radius, Radius Delta, Not Used]\n"
"    vec3 lerpVal = vVignetteFactor.xyz - vec3(vignetteParams.x, vignetteParams.x, vignetteParams.x);\n"
"    lerpVal /= vec3(vignetteParams.z, vignetteParams.z, vignetteParams.z);\n"
"    lerpVal = clamp(lerpVal, 0.0, 1.0);\n"
"    lerpVal = vec3(1.0, 1.0, 1.0) - lerpVal;\n"
"    outColor.xyz *= lerpVal.xyz;\n"
"#endif     // Vignette Support\n"
"#endif     // Camera Support\n"
"}\n"
"\n";   // End of shader string

