<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Qualcomm&copy; Snapdragon&trade; VR SDK: Configuration</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Qualcomm&copy; Snapdragon&trade; VR SDK
   &#160;<span id="projectnumber">4.0.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Configuration </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><table class="doxtable">
<tr>
<th>Name </th><th>type </th><th>default </th><th>description  </th></tr>
<tr>
<td>gEyeBufferWidth </td><td>int </td><td>1024 </td><td>Value returned as recommended eye buffer width (pixels) in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gEyeBufferHeight </td><td>int </td><td>1024 </td><td>Value returned as recommended eye buffer height (pixels) in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gFrustumDisplayWidth </td><td>float </td><td>0 </td><td>Value returned as recommended frustum display width (millimeters)  </td></tr>
<tr>
<td>gFrustumDisplayHeight </td><td>float </td><td>0 </td><td>Value returned as recommended frustum display height (millimeters)  </td></tr>
<tr>
<td>gDisplayWidth </td><td>float </td><td>0 </td><td>Value returned as recommended display width (millimeters)  </td></tr>
<tr>
<td>gDisplayHeight </td><td>float </td><td>0 </td><td>Value returned as recommended display height (millimeters)  </td></tr>
<tr>
<td>gEyeBufferFovX </td><td>float </td><td>0.0f </td><td>Value returned as recommended FOV X in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gEyeBufferFovY </td><td>float </td><td>0.0f </td><td>Value returned as recommended FOV Y in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gFrustum_Convergence </td><td>float </td><td>0.0f </td><td>Value returned as recommended eye convergence in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gFrustum_Pitch </td><td>float </td><td>0.0f </td><td>Value returned as recommended eye pitch in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gLeftFrustum_Near </td><td>float </td><td>0.0508 </td><td>Value returned as recommended view frustum size in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gLeftFrustum_Far </td><td>float </td><td>100.0 </td><td>Value returned as recommended view frustum size in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gLeftFrustum_Left </td><td>float </td><td>-0.031 </td><td>Value returned as recommended view frustum size in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gLeftFrustum_Right </td><td>float </td><td>0.031 </td><td>Value returned as recommended view frustum size in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gLeftFrustum_Top </td><td>float </td><td>0.031 </td><td>Value returned as recommended view frustum size in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gLeftFrustum_Bottom </td><td>float </td><td>-0.031 </td><td>Value returned as recommended view frustum size in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gLeftFrustum_PositionX </td><td>float </td><td>-0.032f </td><td>Value returned as recommended view frustum position in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gLeftFrustum_PositionY </td><td>float </td><td>0.0f </td><td>Value returned as recommended view frustum position in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gLeftFrustum_PositionZ </td><td>float </td><td>0.0f </td><td>Value returned as recommended view frustum position in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gLeftFrustum_RotationX </td><td>float </td><td>0.0f </td><td>Value returned as recommended view frustum rotation in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gLeftFrustum_RotationY </td><td>float </td><td>0.0f </td><td>Value returned as recommended view frustum rotation in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gLeftFrustum_RotationZ </td><td>float </td><td>0.0f </td><td>Value returned as recommended view frustum rotation in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gLeftFrustum_RotationW </td><td>float </td><td>1.0f </td><td>Value returned as recommended view frustum rotation in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gRightFrustum_Near </td><td>float </td><td>0.0508 </td><td>Value returned as recommended view frustum size in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gRightFrustum_Far </td><td>float </td><td>100.0 </td><td>Value returned as recommended view frustum size in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gRightFrustum_Left </td><td>float </td><td>-0.031 </td><td>Value returned as recommended view frustum size in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gRightFrustum_Right </td><td>float </td><td>0.031 </td><td>Value returned as recommended view frustum size in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gRightFrustum_Top </td><td>float </td><td>0.031 </td><td>Value returned as recommended view frustum size in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gRightFrustum_Bottom </td><td>float </td><td>-0.031 </td><td>Value returned as recommended view frustum size in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gRightFrustum_PositionX </td><td>float </td><td>0.032f </td><td>Value returned as recommended view frustum position in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gRightFrustum_PositionY </td><td>float </td><td>0.0f </td><td>Value returned as recommended view frustum position in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gRightFrustum_PositionZ </td><td>float </td><td>0.0f </td><td>Value returned as recommended view frustum position in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gRightFrustum_RotationX </td><td>float </td><td>0.0f </td><td>Value returned as recommended view frustum rotation in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gRightFrustum_RotationY </td><td>float </td><td>0.0f </td><td>Value returned as recommended view frustum rotation in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gRightFrustum_RotationZ </td><td>float </td><td>0.0f </td><td>Value returned as recommended view frustum rotation in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gRightFrustum_RotationW </td><td>float </td><td>1.0f </td><td>Value returned as recommended view frustum rotation in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gLowFoveationArea </td><td>float </td><td>0.0f </td><td>Value returned as recommended low foveation area in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gLowFoveationGainX </td><td>float </td><td>2.0f </td><td>Value returned as recommended low foveation gain x in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gLowFoveationGainY </td><td>float </td><td>2.0f </td><td>Value returned as recommended low foveation gain y in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gLowFoveationMinimum </td><td>float </td><td>0.125f </td><td>Value returned as recommended low foveation minimum in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gMedFoveationArea </td><td>float </td><td>1.0f </td><td>Value returned as recommended med foveation area in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gMedFoveationGainX </td><td>float </td><td>3.0f </td><td>Value returned as recommended med foveation gain x in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gMedFoveationGainY </td><td>float </td><td>3.0f </td><td>Value returned as recommended med foveation gain y in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gMedFoveationMinimum </td><td>float </td><td>0.125f </td><td>Value returned as recommended med foveation minimum in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gHighFoveationArea </td><td>float </td><td>2.0f </td><td>Value returned as recommended high foveation area in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gHighFoveationGainX </td><td>float </td><td>4.0f </td><td>Value returned as recommended high foveation gain x in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gHighFoveationGainY </td><td>float </td><td>4.0f </td><td>Value returned as recommended high foveation gain y in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gHighFoveationMinimum </td><td>float </td><td>0.125f </td><td>Value returned as recommended high foveation minimum in <a class="el" href="structsxr_device_info.html" title="Basic device information to allow the client code to optimally setup their simulation and rendering p...">sxrDeviceInfo</a>  </td></tr>
<tr>
<td>gCalibration_X_0 </td><td>float </td><td>0.00505392f </td><td></td></tr>
<tr>
<td>gCalibration_X_1 </td><td>float </td><td>-0.926172f </td><td></td></tr>
<tr>
<td>gCalibration_X_2 </td><td>float </td><td>-0.377068f </td><td></td></tr>
<tr>
<td>gCalibration_X_3 </td><td>float </td><td>-0.00667208f </td><td></td></tr>
<tr>
<td>gCalibration_Y_0 </td><td>float </td><td>-0.903837f </td><td></td></tr>
<tr>
<td>gCalibration_Y_1 </td><td>float </td><td>-0.165562f </td><td></td></tr>
<tr>
<td>gCalibration_Y_2 </td><td>float </td><td>0.394548f </td><td></td></tr>
<tr>
<td>gCalibration_Y_3 </td><td>float </td><td>0.0630108f </td><td></td></tr>
<tr>
<td>gCalibration_Z_0 </td><td>float </td><td>-0.427847f </td><td></td></tr>
<tr>
<td>gCalibration_Z_1 </td><td>float </td><td>0.338814f </td><td></td></tr>
<tr>
<td>gCalibration_Z_2 </td><td>float </td><td>-0.837945f </td><td></td></tr>
<tr>
<td>gCalibration_Z_3 </td><td>float </td><td>-0.0338611f </td><td></td></tr>
<tr>
<td>gPrincipalPoint_0 </td><td>float </td><td>331.91989f </td><td></td></tr>
<tr>
<td>gPrincipalPoint_1 </td><td>float </td><td>241.84999f </td><td></td></tr>
<tr>
<td>gFocalLength_0 </td><td>float </td><td>268.08765f </td><td></td></tr>
<tr>
<td>gFocalLength_1 </td><td>float </td><td>268.08765f </td><td></td></tr>
<tr>
<td>gRadialDistortion_0 </td><td>float </td><td>0.084730856f </td><td></td></tr>
<tr>
<td>gRadialDistortion_1 </td><td>float </td><td>-0.058135655f </td><td></td></tr>
<tr>
<td>gRadialDistortion_2 </td><td>float </td><td>0.23780872f </td><td></td></tr>
<tr>
<td>gRadialDistortion_3 </td><td>float </td><td>-0.12837055f </td><td></td></tr>
<tr>
<td>gRadialDistortion_4 </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gRadialDistortion_5 </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gRadialDistortion_6 </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gRadialDistortion_7 </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gEnableTimeWarp </td><td>bool </td><td>true </td><td>Override to disable TimeWarp  </td></tr>
<tr>
<td>gDisableReprojection </td><td>bool </td><td>false </td><td>Override to disable reprojection  </td></tr>
<tr>
<td>gDisablePredictedTime </td><td>bool </td><td>false </td><td>Forces sxrGetPredictedDisplayTime to return 0.0  </td></tr>
<tr>
<td>gRenderThreadCore </td><td>int </td><td>3 </td><td>Core id to set render thread affinity for (-1 disables affinity), ignored if the QVR Perf module is active.  </td></tr>
<tr>
<td>gEnableRenderThreadFifo </td><td>bool </td><td>false </td><td>Enable/disable setting SCHED_FIFO scheduling policy on the render thread thread, ignored if the QVR Perf module is active.  </td></tr>
<tr>
<td>gForceMinVsync </td><td>int </td><td>0 </td><td>Override for <a class="el" href="structsxr_frame_params.html" title="Per-frame data needed for time warp, distortion/aberration correction. ">sxrFrameParams</a> minVsync option (0:override disabled, 1 or 2 forced value)  </td></tr>
<tr>
<td>gUseVSyncCallback </td><td>bool </td><td>false </td><td>Override for using the vsync callback, if set to false then check gUseLinePtr  </td></tr>
<tr>
<td>gUseLinePtr </td><td>bool </td><td>true </td><td>Override for using the linePtr interrupt, if set to false Choreographer will be used instead  </td></tr>
<tr>
<td>gDisplayRefreshRateHz </td><td>int </td><td>0 </td><td>Override for android display refresh rate (Hz)  </td></tr>
<tr>
<td>gTimeToHalfExposure </td><td>float </td><td>8.33f </td><td>Time (milliseconds) to get to Half Exposure on the display. This usually T/2, but this property can be used to adjust for OLED vs LCD, getting to 3T/4, additional display delay time, etc.  </td></tr>
<tr>
<td>gTimeToMidEyeWarp </td><td>float </td><td>4.16f </td><td>Time (milliseconds) between warping each eye.  </td></tr>
<tr>
<td>gHeuristicPredictedTime </td><td>bool </td><td>false </td><td>Whether to use a heuristic predicted time  </td></tr>
<tr>
<td>gNumHeuristicEntries </td><td>int </td><td>25 </td><td>How many entries to average to get heuristic predicted time  </td></tr>
<tr>
<td>gHeuristicOffset </td><td>float </td><td>0.0 </td><td>Offset added to the heuristic predicted time  </td></tr>
<tr>
<td>gUseQvrPerfModule </td><td>bool </td><td>true </td><td>Enable/disable the QVR Performance module. If active all thread affinities, priorities and HW clocks will be based on the QVR perf module configuration rather than the SDK configuration  </td></tr>
<tr>
<td>gForceCpuLevel </td><td>int </td><td>-1 </td><td>Override to force CPU performance level (-1: app defined, 0:system defined/off, 1/2/3 for min,medium,max)  </td></tr>
<tr>
<td>gCpuLvl1Min </td><td>int </td><td>30 </td><td>Lower CPU frequency (percentage) bound for min performance level, ignored if the QVR Perf module is active.  </td></tr>
<tr>
<td>gCpuLvl1Max </td><td>int </td><td>50 </td><td>Upper CPU frequency (percentage) bound for min performance level, ignored if the QVR Perf module is active.  </td></tr>
<tr>
<td>gCpuLvl2Min </td><td>int </td><td>51 </td><td>Lower CPU frequency (percentage) bound for medium performance level, ignored if the QVR Perf module is active.  </td></tr>
<tr>
<td>gCpuLvl2Max </td><td>int </td><td>80 </td><td>Upper CPU frequency (percentage) bound for medium performance level, ignored if the QVR Perf module is active.  </td></tr>
<tr>
<td>gCpuLvl3Min </td><td>int </td><td>81 </td><td>Lower CPU frequency (percentage) bound for max performance level, ignored if the QVR Perf module is active.  </td></tr>
<tr>
<td>gCpuLvl3Max </td><td>int </td><td>100 </td><td>Upper CPU frequency (percentage) bound for max performance level , ignored if the QVR Perf module is active.  </td></tr>
<tr>
<td>gForceGpuLevel </td><td>int </td><td>-1 </td><td>Override to force GPU performance level (-1: app defined, 0:system defined/off, 1/2/3 for min,medium,max)  </td></tr>
<tr>
<td>gGpuLvl1Min </td><td>int </td><td>30 </td><td>Lower GPU frequency (percentage) bound for min performance level, ignored if the QVR Perf module is active.  </td></tr>
<tr>
<td>gGpuLvl1Max </td><td>int </td><td>50 </td><td>Upper GPU frequency (percentage) bound for min performance level, ignored if the QVR Perf module is active.  </td></tr>
<tr>
<td>gGpuLvl2Min </td><td>int </td><td>51 </td><td>Lower GPU frequency (percentage) bound for medium performance level, ignored if the QVR Perf module is active.  </td></tr>
<tr>
<td>gGpuLvl2Max </td><td>int </td><td>80 </td><td>Upper GPU frequency (percentage) bound for medium performance level, ignored if the QVR Perf module is active.  </td></tr>
<tr>
<td>gGpuLvl3Min </td><td>int </td><td>81 </td><td>Lower GPU frequency (percentage) bound for max performance level, ignored if the QVR Perf module is active.  </td></tr>
<tr>
<td>gGpuLvl3Max </td><td>int </td><td>100 </td><td>Upper GPU frequency (percentage) bound for max performance level, ignored if the QVR Perf module is active.  </td></tr>
<tr>
<td>gForceTrackingMode </td><td>int </td><td>0 </td><td>Force a specific tracking mode 1 = rotational 3 = rotational &amp; positional  </td></tr>
<tr>
<td>gDisableTrackingRecenter </td><td>bool </td><td>false </td><td>Disable tracking recenter  </td></tr>
<tr>
<td>gUseMagneticRotationFlag </td><td>bool </td><td>true </td><td>If using roational data only, use version that is magnetically corrected  </td></tr>
<tr>
<td>gLifecycleSuspendEnabled </td><td>bool </td><td>false </td><td>Enable Begin/EndXr to control XR suspend/resume  </td></tr>
<tr>
<td>gProximitySuspendEnabled </td><td>bool </td><td>true </td><td>Enable proximity sensor to control XR suspend/resume  </td></tr>
<tr>
<td>gLogLinePtrDelay </td><td>float </td><td>0.0 </td><td>Log line ptr delays longer greater than this value (0.0 = disabled)  </td></tr>
<tr>
<td>gLogSubmitFps </td><td>bool </td><td>false </td><td>Enables output of submit FPS to LogCat  </td></tr>
<tr>
<td>gLogPoseVelocity </td><td>bool </td><td>false </td><td>Log out the tracking velocity  </td></tr>
<tr>
<td>gMaxAngVel </td><td>float </td><td>450.0f </td><td>Detected angular velocity larger than this value will be considered an error in the tracking system (degrees / sec)  </td></tr>
<tr>
<td>gMaxLinearVel </td><td>float </td><td>6.0f </td><td>Detected linear/translational velocity larger than this value will be considered an error in the tracking system (meters / sec)  </td></tr>
<tr>
<td>gLogSubmitFrame </td><td>bool </td><td>false </td><td>Log svrSubmitFrame() parameters  </td></tr>
<tr>
<td>gEnableDebugServer </td><td>bool </td><td>false </td><td>Enables a very basic json-rpc server for interacting with vr while running  </td></tr>
<tr>
<td>gDisableFrameSubmit </td><td>bool </td><td>false </td><td>Debug flag that will prevent the eye buffer render thread from submitted frames to time warp  </td></tr>
<tr>
<td>gControllerService </td><td>char* </td><td>" " </td><td></td></tr>
<tr>
<td>gControllerRingBufferSize </td><td>int </td><td>80 </td><td></td></tr>
<tr>
<td>gEnableRVR </td><td>bool </td><td>false </td><td>Override to run in remote render mode  </td></tr>
<tr>
<td>gEnableRVRLagacy </td><td>bool </td><td>true </td><td>Override to run in remote render mode  </td></tr>
<tr>
<td>gRVRMode </td><td>int </td><td>2 </td><td>1: UDP, 2: USB  </td></tr>
<tr>
<td>gRVRPayloadInRTP </td><td>bool </td><td>false </td><td>Override to enable network/legacy mode  </td></tr>
<tr>
<td>gRVRMTU </td><td>int </td><td>51200 </td><td>Maximum transmission unit size in bytes (eg. usb: 51200 bytes, n/w : 1500 bytes)  </td></tr>
<tr>
<td>gRVRRenderFov </td><td>float </td><td>80.0f </td><td>Render fov. Set 0 to use display fov. Over render is recommended due to addional latency  </td></tr>
<tr>
<td>gRVRRenderFovX </td><td>float </td><td>0.0f </td><td>Render horizontal fov. Set 0 to use display fov. Over render is recommended due to addional latency  </td></tr>
<tr>
<td>gRVRRenderFovY </td><td>float </td><td>0.0f </td><td>Render vertical fov. Set 0 to use display fov. Over render is recommended due to addional latency  </td></tr>
<tr>
<td>gRVRFPS </td><td>float </td><td>75.0f </td><td>Display refersh rate of Hmd display  </td></tr>
<tr>
<td>gRVRSynchronizeToHMDVSync </td><td>int </td><td>1 </td><td>Debug setting. PLL to synchronize render rate to Hmd display refresh rate. 0: disable  </td></tr>
<tr>
<td>gRVRCodec </td><td>char* </td><td>"hevc" </td><td>Video encoder (supported types h264, hevc, nv12, rle(exerimental), rle2(exerimental))  </td></tr>
<tr>
<td>gRVRAvgBitrateMbPS </td><td>int </td><td>30 </td><td>Average video encoder bitrate in MbitsPerSec  </td></tr>
<tr>
<td>gRVRPeakBitrateMbPS </td><td>int </td><td>60 </td><td>Peak video encoder bitrate in MbitsPerSec  </td></tr>
<tr>
<td>gRVRGOPLength </td><td>int </td><td>75 </td><td>GOP size in frames for video encoder  </td></tr>
<tr>
<td>gRVRSlicesPerFrame </td><td>int </td><td>1 </td><td>Slices per frame in encoded picture  </td></tr>
<tr>
<td>gRVRYCoCg </td><td>int </td><td>0 </td><td>Override to enable YCoCg input to video encoder  </td></tr>
<tr>
<td>gRVRPerfMode </td><td>int </td><td>1 </td><td>Encoder performance 0:default, 1:static fps based, 2:dynamic per frame fps, 4:turbo  </td></tr>
<tr>
<td>gRVRF0 </td><td>float </td><td>1.5f </td><td>Performce multiplier (tuned as per platform)  </td></tr>
<tr>
<td>gRVRF1 </td><td>float </td><td>1.5f </td><td>Performce multiplier (tuned as per platform)  </td></tr>
<tr>
<td>gRVRStreamingWidth </td><td>int </td><td>0 </td><td>Fix foveation downscaled width, 0 to disable  </td></tr>
<tr>
<td>gRVRStreamingHeight </td><td>int </td><td>0 </td><td>Fix foveation downscaled height, 0 to disable  </td></tr>
<tr>
<td>gRVRFoveaAngle </td><td>float </td><td>40.0f </td><td>Fix foveation fovea region area  </td></tr>
<tr>
<td>gRVRAudio </td><td>bool </td><td>true </td><td>Override to disable audio  </td></tr>
<tr>
<td>gRVRDisplayFlags </td><td>int </td><td>0 </td><td>mask to show eye texture on host display 0: none , 1: left eye, 2: right eye  </td></tr>
<tr>
<td>gRVRDefaultAtwMode </td><td>int </td><td>0 </td><td>ATW mode 0:3DOF, 1: HarmonicMean, 2: APAPR  </td></tr>
<tr>
<td>gRVRCalculateDepthDFS </td><td>bool </td><td>false </td><td>Override to enable calculate depth using dfs  </td></tr>
<tr>
<td>gRVRIPD </td><td>float </td><td>0.064f </td><td>Value of IPD in meters  </td></tr>
<tr>
<td>gRVRKernelSize </td><td>int </td><td>5 </td><td>Don't override  </td></tr>
<tr>
<td>gRVRMaxDisparity </td><td>int </td><td>24 </td><td>Don't override  </td></tr>
<tr>
<td>gRVRLocalSizeX </td><td>int </td><td>32 </td><td>Don't override  </td></tr>
<tr>
<td>gRVRLocalSizeY </td><td>int </td><td>32 </td><td>Don't override  </td></tr>
<tr>
<td>gRVRDownScaleFactor </td><td>int </td><td>5 </td><td>Don't override  </td></tr>
<tr>
<td>gRVRPositionScaleZ </td><td>float </td><td>1.0f </td><td>Don't override  </td></tr>
<tr>
<td>gRVRFarClipPlane </td><td>float </td><td>-1.0f </td><td>Don't override  </td></tr>
<tr>
<td>gRVREnableHeartbeat </td><td>bool </td><td>false </td><td>Don't override  </td></tr>
<tr>
<td>gRVRWaitForHMD </td><td>bool </td><td>true </td><td>Don't override. Wait for USB connection  </td></tr>
<tr>
<td>gRVRUsePoseSocket </td><td>int </td><td>0 </td><td>Don't override. Reserved for future use  </td></tr>
<tr>
<td>gRVRFlags </td><td>int </td><td>0 </td><td>Don't override. Reserved for future use  </td></tr>
<tr>
<td>gEnableVRCasting </td><td>bool </td><td>false </td><td>Debug flag to force enable VR Casting feature  </td></tr>
<tr>
<td>gPresentationThreadCore </td><td>int </td><td>6 </td><td>Core id to set presentation thread affinity for (-1 disables affinity), ignored if the QVR Perf module is active.  </td></tr>
<tr>
<td>gEnablePresentationThreadFifo </td><td>bool </td><td>true </td><td>Enable/disable setting SCHED_FIFO scheduling policy on the presentation thread (must be true if gBusyWait is false to avoid tearing), ignored if the QVR Perf module is active.  </td></tr>
<tr>
<td>gEnable3DR </td><td>bool </td><td>false </td><td>Override to initialize 3DR subsystem  </td></tr>
<tr>
<td>gEnableAnchors </td><td>bool </td><td>false </td><td>Override to initialize Anchors subsystem  </td></tr>
<tr>
<td>gDebugServerPort </td><td>int </td><td>8080 </td><td>Port for the debug server to listen for incoming requests on  </td></tr>
<tr>
<td>gLogEvents </td><td>bool </td><td>false </td><td>Enables logcat logging of events  </td></tr>
<tr>
<td>gSensorOrientationCorrectX </td><td>float </td><td>0.0f </td><td>Adjustment if sensors are physically rotated (degrees)  </td></tr>
<tr>
<td>gSensorOrientationCorrectY </td><td>float </td><td>0.0f </td><td>Adjustment if sensors are physically rotated (degrees)  </td></tr>
<tr>
<td>gSensorOrientationCorrectZ </td><td>float </td><td>0.0f </td><td>Adjustment if sensors are physically rotated (degrees)  </td></tr>
<tr>
<td>gSensorHomePosition </td><td>int </td><td>0 </td><td>Base device configuration. 0 = Landscape Left; 1 = Landscape Right  </td></tr>
<tr>
<td>gSensorHeadOffsetX </td><td>float </td><td>0.0f </td><td>Adjustment for device physical distance from head (meters)  </td></tr>
<tr>
<td>gSensorHeadOffsetY </td><td>float </td><td>0.0f </td><td>Adjustment for device physical distance from head (meters)  </td></tr>
<tr>
<td>gSensorHeadOffsetZ </td><td>float </td><td>0.0762 </td><td>Adjustment for device physical distance from head (meters)  </td></tr>
<tr>
<td>gMinPoseQuality </td><td>float </td><td>0.7 </td><td>Minimum pose quality (In range [0.0, 1.0]) allowed  </td></tr>
<tr>
<td>gIMUSensorPoseDelay </td><td>float </td><td>0.0 </td><td>Base IMU delay (milliseconds). How old is pose before it is recorded?  </td></tr>
<tr>
<td>gMaxPredictedTime </td><td>float </td><td>75.0 </td><td>Max allowable predicted pose time (milliseconds)  </td></tr>
<tr>
<td>gLogMaxPredictedTime </td><td>bool </td><td>true </td><td>Enable/disable logging when max predicted time is enforced  </td></tr>
<tr>
<td>gLogRawSensorData </td><td>bool </td><td>false </td><td>Enable/disable logging of sensor values directly from the service  </td></tr>
<tr>
<td>gUseFixedRotation </td><td>bool </td><td>false </td><td>Enable/disable setting of sensor rotation value directly  </td></tr>
<tr>
<td>gFixedRotationQuatX </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gFixedRotationQuatY </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gFixedRotationQuatZ </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gFixedRotationQuatW </td><td>float </td><td>1.0f </td><td></td></tr>
<tr>
<td>gFixedRotationSpeedX </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gFixedRotationSpeedY </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gFixedRotationSpeedZ </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gFixedRotationBounceX </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gFixedRotationBounceY </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gFixedRotationBounceZ </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gUseFixedPosition </td><td>bool </td><td>false </td><td>Enable/disable setting of sensor position value directly  </td></tr>
<tr>
<td>gFixedPositionX </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gFixedPositionY </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gFixedPositionZ </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gFixedPositionEndX </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gFixedPositionEndY </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gFixedPositionEndZ </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gFixedPositionSpeed </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gEnableMotionVectors </td><td>bool </td><td>false </td><td>Enables motion vector support  </td></tr>
<tr>
<td>gForceAppEnableMotionVectors </td><td>bool </td><td>false </td><td>Force motion vectors for all applications. Otherwise up to application  </td></tr>
<tr>
<td>gUseMotionVectors </td><td>bool </td><td>true </td><td>For Power: Whether or not to use motion data  </td></tr>
<tr>
<td>gLogMotionVectors </td><td>bool </td><td>false </td><td>Enables logging of motion vector activities  </td></tr>
<tr>
<td>gSmoothMotionVectors </td><td>bool </td><td>true </td><td>Motion data is average of surrounding samples  </td></tr>
<tr>
<td>gSmoothMotionVectorsWithGPU </td><td>bool </td><td>true </td><td>Motion data smoothing is done on the GPU  </td></tr>
<tr>
<td>gRenderMotionVectors </td><td>bool </td><td>false </td><td>Enables display of motion vectors as one of the eye buffers  </td></tr>
<tr>
<td>gRenderMotionInput </td><td>bool </td><td>false </td><td>Enables display of motion input. Current/Previous are the Left/Right eyes (for checking warp). Subject to gRenderMotionVectors  </td></tr>
<tr>
<td>gGenerateBothEyes </td><td>bool </td><td>false </td><td>Generate separate motion data for each eye. Otherwise, same data is used for both  </td></tr>
<tr>
<td>gDisableLensCorrection </td><td>bool </td><td>false </td><td>Override to disable any lens correction during time warp  </td></tr>
<tr>
<td>gDirectModeWarp </td><td>bool </td><td>true </td><td>Override to enable/disable "direct" non-binning mode for time warp rendering  </td></tr>
<tr>
<td>gSingleBufferWindow </td><td>bool </td><td>true </td><td>Override to enable/disable use of single buffer surface for time warp  </td></tr>
<tr>
<td>gTimeWarpThreadCore </td><td>int </td><td>2 </td><td>Core affinity for time warp thread (-1=system defined), ignored if the QVR Perf module is active.  </td></tr>
<tr>
<td>gTimeWarpClearBuffer </td><td>bool </td><td>false </td><td>Enable/disable clearing the time warp surface before rendering  </td></tr>
<tr>
<td>gBusyWait </td><td>bool </td><td>false </td><td>Enable/disable "busy" wait between eyes (on some builds use of nanosleep function can oversleep by as much as 10ms if FIFO isn't set on the sleeping thread)  </td></tr>
<tr>
<td>gEnableWarpThreadFifo </td><td>bool </td><td>true </td><td>Enable/disable setting SCHED_FIFO scheduling policy on the warp thread (must be true if gBusyWait is false to avoid tearing), ignored if the QVR Perf module is active.  </td></tr>
<tr>
<td>gRecenterFrames </td><td>int </td><td>0 </td><td>Number of frames to disable reprojection after sensors are recentered  </td></tr>
<tr>
<td>gSensorInitializeFrames </td><td>int </td><td>0 </td><td>Number of frames to disable display after sensors are started  </td></tr>
<tr>
<td>gTimeWarpMinLoopTime </td><td>int </td><td>0 </td><td>For testing: minimum time (milliseconds) for a timewarp loop. Can be used to simulate timewarp not able to keep up with render. Set to 0 to disable test  </td></tr>
<tr>
<td>gTimeWarpWaitBias </td><td>float </td><td>0.0f </td><td>Bias applied to the time we wait to kick off warping at mid frame  </td></tr>
<tr>
<td>gTimeWarpWaitFramePercentage </td><td>float </td><td>0.5f </td><td>Percent of the frame time the display buffer has transfered half the data (default .5)  </td></tr>
<tr>
<td>gTimeWarpDelayBetweenEyes </td><td>bool </td><td>true </td><td>Second eye is rendered at apporpriate vsync time. Otherwise, both eyes rendered back to back  </td></tr>
<tr>
<td>gSwapEyeBuffers </td><td>bool </td><td>false </td><td>Had a device that swapped DSI 0/1 so left eye went to right eye and right to left  </td></tr>
<tr>
<td>gTimeWarpClearColorR </td><td>float </td><td>0.0f </td><td>Fill color for TimeWarp clear (if gTimeWarpClearBuffer enabled)  </td></tr>
<tr>
<td>gTimeWarpClearColorG </td><td>float </td><td>0.0f </td><td>Fill color for TimeWarp clear (if gTimeWarpClearBuffer enabled)  </td></tr>
<tr>
<td>gTimeWarpClearColorB </td><td>float </td><td>0.0f </td><td>Fill color for TimeWarp clear (if gTimeWarpClearBuffer enabled)  </td></tr>
<tr>
<td>gTimeWarpClearColorA </td><td>float </td><td>1.0f </td><td>Fill color for TimeWarp clear (if gTimeWarpClearBuffer enabled)  </td></tr>
<tr>
<td>gSupportColorPlaneWarp </td><td>bool </td><td>false </td><td>Some displays support different color planes.  </td></tr>
<tr>
<td>gColorPlaneTimeOffsetR </td><td>float </td><td>0.0f </td><td>When warping, each color plane has a different time (milliseconds) to be warped  </td></tr>
<tr>
<td>gColorPlaneTimeOffsetG </td><td>float </td><td>0.0f </td><td>When warping, each color plane has a different time (milliseconds) to be warped  </td></tr>
<tr>
<td>gColorPlaneTimeOffsetB </td><td>float </td><td>0.0f </td><td>When warping, each color plane has a different time (milliseconds) to be warped  </td></tr>
<tr>
<td>gTimeWarpEnabledEyeMask </td><td>int </td><td>3 </td><td>sxrEyeMask Bit Field: 1 = Left; 2 = Right; 3 = Both  </td></tr>
<tr>
<td>gForceColorSpace </td><td>int </td><td>-1.0f </td><td>Force warp colorspace -1 = app specified, 0 = linear, 1 = sRGB  </td></tr>
<tr>
<td>gApplyDisplaySkew </td><td>bool </td><td>false </td><td>Apply a skew during warp to counteract the impact of display rates  </td></tr>
<tr>
<td>gApplyDisplaySquash </td><td>bool </td><td>false </td><td>Apply a skew during warp to counteract the impact of display rates  </td></tr>
<tr>
<td>gApplyDisplayBias </td><td>bool </td><td>false </td><td>Apply a bias during warp to counteract the impact of display rates  </td></tr>
<tr>
<td>gSkewScaleFactor </td><td>float </td><td>1.0f </td><td>Scale factor to apply to the display skewing  </td></tr>
<tr>
<td>gSquashScaleFactor </td><td>float </td><td>1.0f </td><td>Scale factor to apply to the display squash  </td></tr>
<tr>
<td>gBiasScaleFactor </td><td>float </td><td>1.0f </td><td>Bias to shift - fraction of a frame time - default value is 1 frame, so 2 = 2 frames later, 0 is no bias  </td></tr>
<tr>
<td>gCompositeRadius </td><td>float </td><td>0.25f </td><td>Any layer quad outside this range will be composited  </td></tr>
<tr>
<td>gWarpMeshType </td><td>int </td><td>0 </td><td>Warp mesh type: 0 = Columns (Left To Right); 1 = Columns (Right To Left); 2 = Rows (Top To Bottom); 3 = Rows (Bottom To Top)  </td></tr>
<tr>
<td>gWarpMeshRows </td><td>int </td><td>50 </td><td>Number of rows in the warp mesh grid  </td></tr>
<tr>
<td>gWarpMeshCols </td><td>int </td><td>50 </td><td>Number of columns in the warp mesh grid  </td></tr>
<tr>
<td>gLayerMeshRows </td><td>int </td><td>8 </td><td>Number of rows in the layer mesh grid  </td></tr>
<tr>
<td>gLayerMeshCols </td><td>int </td><td>8 </td><td>Number of columns in the layer mesh grid  </td></tr>
<tr>
<td>gWarpEqrMeshRadius </td><td>float </td><td>2.0 </td><td>Radius of warp mesh used for EquiRectangular display (Affects curvature)  </td></tr>
<tr>
<td>gWarpEqrMeshScale </td><td>float </td><td>0.9 </td><td>Amount of screen covered by the EquiRectangular warp mesh  </td></tr>
<tr>
<td>gWarpMeshMinX </td><td>float </td><td>-1.0f </td><td>Screen space coordinate of minimum X-Value  </td></tr>
<tr>
<td>gWarpMeshMaxX </td><td>float </td><td>1.0f </td><td>Screen space coordinate of maximum X-Value  </td></tr>
<tr>
<td>gWarpMeshMinY </td><td>float </td><td>-1.0f </td><td>Screen space coordinate of minimum Y-Value  </td></tr>
<tr>
<td>gWarpMeshMaxY </td><td>float </td><td>1.0f </td><td>Screen space coordinate of maximum Y-Value  </td></tr>
<tr>
<td>gMeshOffsetLeftX </td><td>float </td><td>0.0f </td><td>Screen space adjustment for left mesh to center under lens  </td></tr>
<tr>
<td>gMeshOffsetLeftY </td><td>float </td><td>0.0f </td><td>Screen space adjustment for left mesh to center under lens  </td></tr>
<tr>
<td>gMeshOffsetRightX </td><td>float </td><td>0.0f </td><td>Screen space adjustment for right mesh to center under lens  </td></tr>
<tr>
<td>gMeshOffsetRightY </td><td>float </td><td>0.0f </td><td>Screen space adjustment for right mesh to center under lens  </td></tr>
<tr>
<td>gMeshVignette </td><td>bool </td><td>false </td><td>Enable/Disable vignette feature on the warp mesh  </td></tr>
<tr>
<td>gVignetteRadius </td><td>float </td><td>0.7f </td><td>Start radius of vignette feature. Completes at gMeshDiscardUV applied to lens polynomial  </td></tr>
<tr>
<td>gClampBorderEnabled </td><td>bool </td><td>true </td><td>Enable/disable clamp to border color on eye buffers  </td></tr>
<tr>
<td>gClampBorderColorR </td><td>float </td><td>0.0f </td><td>Fill color for clamp to border (if enabled)  </td></tr>
<tr>
<td>gClampBorderColorG </td><td>float </td><td>0.0f </td><td>Fill color for clamp to border (if enabled)  </td></tr>
<tr>
<td>gClampBorderColorB </td><td>float </td><td>0.0f </td><td>Fill color for clamp to border (if enabled)  </td></tr>
<tr>
<td>gClampBorderColorA </td><td>float </td><td>1.0f </td><td>Fill color for clamp to border (if enabled)  </td></tr>
<tr>
<td>gClampBorderOverlayEnabled </td><td>bool </td><td>true </td><td>Enable/disable clamp to border color on overlay buffers  </td></tr>
<tr>
<td>gClampBorderOverlayColorR </td><td>float </td><td>0.0f </td><td>Fill color for clamp to border (if enabled)  </td></tr>
<tr>
<td>gClampBorderOverlayColorG </td><td>float </td><td>0.0f </td><td>Fill color for clamp to border (if enabled)  </td></tr>
<tr>
<td>gClampBorderOverlayColorB </td><td>float </td><td>0.0f </td><td>Fill color for clamp to border (if enabled)  </td></tr>
<tr>
<td>gClampBorderOverlayColorA </td><td>float </td><td>1.0f </td><td>Fill color for clamp to border (if enabled)  </td></tr>
<tr>
<td>gOcclusionMeshEnabled </td><td>bool </td><td>false </td><td>Enable/disable occlude mesh 3dr  </td></tr>
<tr>
<td>gOcclusionMeshColorR </td><td>float </td><td>0.0f </td><td>Fill color for occlude mesh (if enabled)  </td></tr>
<tr>
<td>gOcclusionMeshColorG </td><td>float </td><td>0.0f </td><td>Fill color for occlude mesh (if enabled)  </td></tr>
<tr>
<td>gOcclusionMeshColorB </td><td>float </td><td>0.0f </td><td>Fill color for occlude mesh (if enabled)  </td></tr>
<tr>
<td>gOcclusionMeshColorA </td><td>float </td><td>0.0f </td><td>Fill alpha for occlude mesh (if enabled)  </td></tr>
<tr>
<td>gStencilMeshEnabled </td><td>bool </td><td>false </td><td>Enable/disable stencil mesh optimization on eye buffers  </td></tr>
<tr>
<td>gStencilMeshRadius </td><td>float </td><td>0.95f </td><td>Radius of stencil mesh used for eye buffers  </td></tr>
<tr>
<td>gStencilMeshColorR </td><td>float </td><td>0.0f </td><td>Fill color for stencil mesh (if enabled)  </td></tr>
<tr>
<td>gStencilMeshColorG </td><td>float </td><td>0.0f </td><td>Fill color for stencil mesh (if enabled)  </td></tr>
<tr>
<td>gStencilMeshColorB </td><td>float </td><td>0.0f </td><td>Fill color for stencil mesh (if enabled)  </td></tr>
<tr>
<td>gStencilMeshColorA </td><td>float </td><td>1.0f </td><td>Fill color for stencil mesh (if enabled)  </td></tr>
<tr>
<td>gEnableBoundarySystem </td><td>bool </td><td>false </td><td>Enable/disable Boundary display  </td></tr>
<tr>
<td>gForceDisplayBoundarySystem </td><td>bool </td><td>false </td><td>Forces the display of the Boundary display  </td></tr>
<tr>
<td>gLogBoundarySystem </td><td>bool </td><td>false </td><td>Enable/disable loging of Boundary system  </td></tr>
<tr>
<td>gEnableBoundaryMesh </td><td>bool </td><td>false </td><td>Enable/disable Boundary feature using mesh  </td></tr>
<tr>
<td>gBoundaryWarpMeshRows </td><td>int </td><td>2 </td><td>Number of rows in the Boundary mesh  </td></tr>
<tr>
<td>gBoundaryWarpMeshCols </td><td>int </td><td>2 </td><td>Number of cols in the Boundary mesh  </td></tr>
<tr>
<td>gBoundaryZoneMinX </td><td>float </td><td>-4.0 </td><td>Boundary zone size (Real world coordinates in meters)  </td></tr>
<tr>
<td>gBoundaryZoneMaxX </td><td>float </td><td>4.0 </td><td>Boundary zone size (Real world coordinates in meters)  </td></tr>
<tr>
<td>gBoundaryZoneMinY </td><td>float </td><td>-4.0 </td><td>Boundary zone size (Real world coordinates in meters)  </td></tr>
<tr>
<td>gBoundaryZoneMaxY </td><td>float </td><td>4.0 </td><td>Boundary zone size (Real world coordinates in meters)  </td></tr>
<tr>
<td>gBoundaryZoneMinZ </td><td>float </td><td>-4.0 </td><td>Boundary zone size (Real world coordinates in meters)  </td></tr>
<tr>
<td>gBoundaryZoneMaxZ </td><td>float </td><td>4.0 </td><td>Boundary zone size (Real world coordinates in meters)  </td></tr>
<tr>
<td>gBoundaryUVScale </td><td>float </td><td>10.0 </td><td>Boundary zone texture repeat scale (grid spacing)  </td></tr>
<tr>
<td>gBoundaryGridWidth </td><td>float </td><td>0.1 </td><td>Boundary zone grid line width (fractional part of result of gBoundaryUVScale)  </td></tr>
<tr>
<td>gBoundaryVisabilityRadius </td><td>float </td><td>0.5 </td><td>Distance from Boundary zone boundaries when the Boundary mesh starts to be visible  </td></tr>
<tr>
<td>gBoundaryVisabilityScale </td><td>float </td><td>1.5 </td><td>Scale for how quickly the Boundary mesh fades in to full opacity  </td></tr>
<tr>
<td>gBoundaryMeshColorR </td><td>float </td><td>1.0 </td><td>Boundary mesh color  </td></tr>
<tr>
<td>gBoundaryMeshColorG </td><td>float </td><td>1.0 </td><td>Boundary mesh color  </td></tr>
<tr>
<td>gBoundaryMeshColorB </td><td>float </td><td>1.0 </td><td>Boundary mesh color  </td></tr>
<tr>
<td>gBoundaryMeshColorA </td><td>float </td><td>1.0 </td><td>Boundary mesh color  </td></tr>
<tr>
<td>gLensOffsetLeftX </td><td>float </td><td>0.0f </td><td>Horizontal lens offset left  </td></tr>
<tr>
<td>gLensOffsetLeftY </td><td>float </td><td>0.0f </td><td>Vertical lens offset left  </td></tr>
<tr>
<td>gLensOffsetRightX </td><td>float </td><td>0.0f </td><td>Horizontal lens offset right  </td></tr>
<tr>
<td>gLensOffsetRightY </td><td>float </td><td>0.0f </td><td>Vertical lens offset right  </td></tr>
<tr>
<td>gLensScale </td><td>float </td><td>1.0f </td><td>Uniform lens scale  </td></tr>
<tr>
<td>gLensScaleX </td><td>float </td><td>0.0f </td><td>Uniform lens scale width (0 means undefined)  </td></tr>
<tr>
<td>gLensScaleY </td><td>float </td><td>0.0f </td><td>Uniform lens scale height (0 means undefined)  </td></tr>
<tr>
<td>gLensPolyUseXYZ </td><td>bool </td><td>false </td><td></td></tr>
<tr>
<td>gLensInverse </td><td>bool </td><td>false </td><td></td></tr>
<tr>
<td>gLensPolyK0 </td><td>float </td><td>1.0f </td><td></td></tr>
<tr>
<td>gLensPolyK1 </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gLensPolyK2 </td><td>float </td><td>0.22f </td><td></td></tr>
<tr>
<td>gLensPolyK3 </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gLensPolyK4 </td><td>float </td><td>0.24f </td><td></td></tr>
<tr>
<td>gLensPolyK5 </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gLensPolyK6 </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gLensXYZPolyK0 </td><td>float </td><td>1.0f </td><td></td></tr>
<tr>
<td>gLensXYZPolyK1 </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gLensXYZPolyK2 </td><td>float </td><td>-0.3940f </td><td></td></tr>
<tr>
<td>gLensXYZPolyK3 </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gLensXYZPolyK4 </td><td>float </td><td>0.1234 </td><td></td></tr>
<tr>
<td>gLensXYZPolyK5 </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gLensXYZPolyK6 </td><td>float </td><td>-0.0211 </td><td></td></tr>
<tr>
<td>gChromaticPolyK0_R </td><td>float </td><td>0.994f </td><td></td></tr>
<tr>
<td>gChromaticPolyK1_R </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gChromaticPolyK2_R </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gChromaticPolyK3_R </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gChromaticPolyK4_R </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gChromaticPolyK5_R </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gChromaticPolyK6_R </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gChromaticPolyK0_G </td><td>float </td><td>1.003f </td><td></td></tr>
<tr>
<td>gChromaticPolyK1_G </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gChromaticPolyK2_G </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gChromaticPolyK3_G </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gChromaticPolyK4_G </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gChromaticPolyK5_G </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gChromaticPolyK6_G </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gChromaticPolyK0_B </td><td>float </td><td>1.014f </td><td></td></tr>
<tr>
<td>gChromaticPolyK1_B </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gChromaticPolyK2_B </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gChromaticPolyK3_B </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gChromaticPolyK4_B </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gChromaticPolyK5_B </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gChromaticPolyK6_B </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gChromaticPixelBorder </td><td>float </td><td>0.0f </td><td></td></tr>
<tr>
<td>gMeshDiscardUV </td><td>float </td><td>1.0f </td><td>After lens polynomial applied, anything greater than this value will be discarded.  </td></tr>
<tr>
<td>gLogEyeOverSleep </td><td>bool </td><td>false </td><td>Enable/disable checking and logging of oversleep during eye buffer rendering  </td></tr>
<tr>
<td>gLogFrameDoubles </td><td>bool </td><td>false </td><td>Enables output of LogCat messages when TimeWarp frames are reused  </td></tr>
<tr>
<td>gLogMeshCreation </td><td>bool </td><td>false </td><td>Enables output of LogCat messages when meshes are created  </td></tr>
<tr>
<td>gLogVSyncData </td><td>bool </td><td>false </td><td>Enables output of LogCat messages when VSync data is updated  </td></tr>
<tr>
<td>gLogPrediction </td><td>bool </td><td>false </td><td></td></tr>
<tr>
<td>gLogDroppedFrames </td><td>bool </td><td>false </td><td>If next frame warped is not one more than last frame (Application may break this if it assigns wrong frameIndx)  </td></tr>
<tr>
<td>gLogShaderUniforms </td><td>bool </td><td>false </td><td></td></tr>
<tr>
<td>gLogEyeRender </td><td>bool </td><td>false </td><td></td></tr>
<tr>
<td>gScreenWidthMM </td><td>float </td><td>125.4400f </td><td>SVR845  </td></tr>
<tr>
<td>gUseDistortionMeshData </td><td>bool </td><td>false </td><td></td></tr>
<tr>
<td>gMotionToPhotonC </td><td>float </td><td>10.0f </td><td>Scale factor driving intensity of color from angular velocity  </td></tr>
<tr>
<td>gMotionToPhotonAccThreshold </td><td>float </td><td>0.999998f </td><td>Minimum threshold for motion to be considered significant enough to light the display  </td></tr>
</table>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
